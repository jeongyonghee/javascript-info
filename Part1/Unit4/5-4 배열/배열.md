#### 배열
  * 순서가 있는 컬렉션을 저장할 떄 쓰는 자료구조

#### 배열 선언
  * 배열 생성 문법
```js
let arr = new Array();
let arr = [];
```
  * 대부분 let arr = [] 로 선언 초기 요소를 넣어주는 것도 가능
  * let fruits = ["사과", "오렌지", "자두"];
  * 배열 요소는 0부터 시작하는 인덱스 숫자가 매겨져 있다. 특정 요소를 얻고 싶다면 대괄호 안에 인덱스
  * fruits[0] = 사과
  * 수정도 가능 fruits[0] = "배"  -> 사과가 배로 수정됨
  * 배열 추가도 가능 
  * fruits[3] = '레몬' -> 4번째에 레몬 추가
  * length 사용 시 요소가 몇 개 인지 알아낼 수 있다. 
  * alert을 사용해 요소 전체 출력 가능 
  * alert(fruits) -> 사과,오렌지,자두 출력
  * 배열 요소의 자료형엔 제약이 없다.
```js
// 요소에 여러 가지 자료형이 섞여 있습니다.
let arr = [ '사과', { name: '이보라' }, true, function() { alert('안녕하세요.'); } ];

// 인덱스가 1인 요소(객체)의 name 프로퍼티를 출력합니다.
alert( arr[1].name ); // 이보라

// 인덱스가 3인 요소(함수)를 실행합니다.
arr[3](); // 안녕하세요.
```

#### pop push와 shift unShift
  * 큐(queue) 자료구조의 경우
  * 배열과 마찬가지 순서가 있는 컬렉션 저장
  * push : 배열 맨 끝에 요소를 추가
  * shift : 배열 맨 앞의 요소를 꺼내 제거한다.(남아있는 요소들은 한칸씩 앞으로 땡겨짐) 
  * 스택(stack) 자료구조의 경우
  * 한쪽 끝에 요소를 더하거나 뺄 수 있게 해주는 자료구조
  * push : 요소를 스택 끝에 집어 넣는다. (큐의 push와 스택의 push는 동일한 기능 아닌가요?)
  * pop : 스택 끝 요소를 제거하고 추출 

```js
// pop 배열 끝의 요소 제거 제거한 요소 반환
let fruits = ["사과", "오렌지", "배"];

alert( fruits.pop() ); // 배열에서 "배"를 제거하고 제거된 요소를 얼럿창에 띄웁니다.

alert( fruits ); // 사과,오렌지
```
```js
// push 배열 끝에 요소 추가
let fruits = ["사과", "오렌지"];

fruits.push("배");

alert( fruits ); // 사과,오렌지,배
```
```js
// shift 배열 앞에 요소 제거 제거한 요소 반환
let fruits = ["사과", "오렌지", "배"];

alert( fruits.shift() ); // 배열에서 "사과"를 제거하고 제거된 요소를 얼럿창에 띄웁니다.

alert( fruits ); // 오렌지,배
```
```js
//unshift 배열 앞에 요소 추가
let fruits = ["오렌지", "배"];

fruits.unshift('사과');

alert( fruits ); // 사과,오렌지,배
```

#### 배열의 내부 동작 원리
  * 배열은 특별한 종류의 객체 배열은 키가 숫자(인덱스 번호) 
  * 배열은 객체처럼 동작 참조를 통해 복사된다.
```js
let fruits = ["바나나"]

let arr = fruits; // 참조를 복사함(두 변수가 같은 객체를 참조)

alert( arr === fruits ); // true

arr.push("배"); // 참조를 이용해 배열을 수정합니다.

alert( fruits ); // 바나나,배 - 요소가 두 개가 되었습니다.
```
  * 배열을 일반 객체처럼 다룰 시 배열에 적용되는 최적화 기법이 동작하지 않아 배열 특유의 이점이 사라진다.
```js
let fruits = []; // 빈 배열을 하나 만듭니다.

fruits[99999] = 5; // 배열의 길이보다 훨씬 큰 숫자를 사용해 프로퍼티를 만듭니다.

fruits.age = 25; // 임의의 이름을 사용해 프로퍼티를 만듭니다.
```
  * arr.test = 5 숫자가 아닌 값을 프로퍼티 키로 이용하는 경우
  * arr[0] 과 arr[1000]만 추가하고 그 사이 요소가 없을 경우
  * arr[1000], arr[999] 같이 요소를 역순으로 채우는 경우
  * 임의의 키를 사용해야 한다면 배열보단 객체 {} 가 적합한 자료 구조

#### 성능
  * 성능상 push와 pop는 빠르지만 shift와 unshift는 느리다

#### 반복문
  * for문은 배열을 순회할 때 쓰는 가장 오래된 방법
```js
let arr = ["사과", "오렌지", "배"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] ); 
  // 0, 1, 2 가 순차적으로 출력 arr[0]은 사과 arr[1]은 오렌지 arr[2]는 배
  // 결과적으로 사과 오렌지 배가 출력됨
}
```
  * 배열의 또 다른 순회 문법으로 for ~ of 가 있다.
```js
let fruits = ["사과", "오렌지", "자두"];

// 배열 요소를 대상으로 반복 작업을 수행합니다.
for (let fruit of fruits) {
  alert( fruit );
}  
```
  * for ~ of 를 사용하면 현재 요소의 인덱스를 얻는게 아닌 값만 얻는다.
  * 배열은 객체형에 속하므려  for ~ in 도 사용 가능
```js
let arr = ["사과", "오렌지", "배"];

for (let key in arr) {
  alert( arr[key] ); // 사과, 오렌지, 배
}
```
  * 배열에 for ~ in 을 사용하면 다음과 같은문제가 발생 다른 반복문 사용해야함
  * 1. for ~ in 반복문은 모든 프로퍼티 대상 순회 필요 없는 프로퍼티들이 문제 일으킬 가능성
  * 2. 배열이 아닌 객체와 함께 사용할 때 최적화 객체에 사용하는거에 비해 느리다

#### length 프로퍼티
  * 배열을 조작할 시 length 프로퍼티 자동 갱신 
  * length 프로퍼티는 요소의 개수가 아닌 가장 큰 인덱스 +1 
  * length는 인덱스 번호처럼  0부터 시작하는 것이 아닌 길이를 반환하기 때문에 1부터 시작 그래서 +1 해주어야함
  * length의 값을 감소 시키면 배열이 잘린다. 잘린 배열은 복구 X

#### new Array()
  * let arr = new Array("사과", "배", "파인애플")
  * new Array(2) 이런 식으로 (숫자)를 넣어 만들 시에 요소는 undefined가 된다. 그래서 잘 사용 X

#### 다차원 배열
   * 배열은 배열의 요소가 될 수 있다. 이런 배열을 다차원 배열이라 부른다.
   * 다차원 배열은 행렬을 저장하는 용도로 사용
```js
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[1][1] ); // 5, 중심에 있는 요소
```
#### toString
  * 배열엔 toString이 구현되어 있어 배열을 호출하면 요소를 쉼표로 구분한 "문자열" 이 반환
```js
let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
```
  * 배열엔 Symbol.toPrimitive나 valuOf 메서드가 없다.
  * 문자열로의 형 변환이 일어나 [] 는 빈 문자열 [1] 은 "1" [1,2] 는 "1,2" 로 반환한다.
```js
alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
```
  * + 는 피연산자 중 하나가 문자열일 경우 나머지 피연산자도 문자열로 변환
