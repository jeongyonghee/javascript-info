### 재귀와 스택
  * 재귀란 큰 목표 작업 하나를 동일하면서 간단한 작업 여러개로 나눌 수 있을 때 유용한 프로그래밍 패턴이다.
  * 목표 작업을 간단한 동작 하나와 목표작업을 변형한 작업으로 단순화 시킬 수 있을 때도 재귀를 사용할 수 있다.
  * 특정 자료구조를 다뤄야 할 떄도 재귀가 사용
  * 함수에서 다른 함수를 호출해야 할 때 이때 함수가 자기 자신을 호출할 수 있는데 이를 재귀라고 부른다.

#### 두 가지 사고방식
  * 재귀를 알아보는 예시 : x를 n제곱해 주는 함수 pow(x,n)을 만든다. pow(x,n)은 x를 n번 곱해주기 때문에 아래 결과를 만족해야 한다.
```js
pow(2, 2) = 4
pow(2, 3) = 8
pow(2, 4) = 16
```
  * 구현하는 방법은 두 가지가 있다.
  * 1.반복적인 사고를 통한 방법: for 루프
```js
function pow(x, n) {
  let result = 1;

  // 반복문을 돌면서 x를 n번 곱함
  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

alert( pow(2, 3) ); // 8
```
 * 2.재귀적인 사고를 통한 방법 : 작업을 단순화 하고 자기 자신을 호출함
```js
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) ); // 8
```
 * n == 1 일때 : 명확한 결과값 도출 재귀의 베이스라고 하며 pow(x, 1) 은 x다.
 * n != 1 일때 : pow(x,n) 은 x * pow(x,n -1) 으로 표현 수학식으론 xn = x * xn-1(이 부분은 이해가 안갑니다) 이를 재귀단계라고 부른다.
 * 재귀 단계는 n이 1이 될때까지 계속 이어집니다.(1이 될때까지 영원히 작업을 반복한다는건가요?)
 * pow(2, 4) 를 계산하려면 아래와 같은 재귀 단계가 이어진다.
 * pow(2, 4) = 2 * pow(2, 3)
 * pow(2, 3) = 2 * pow(2, 2)
 * pow(2, 2) = 2 * pow(2, 1)
 * pow(2, 1) = 2 
 * 재귀를 이용하면 함수 호출의 결과가 명확해질 때까지 함수 호출을 더 간단한 함수 호출로 계속 줄일 수 있다.
 * 가장 처음 하는 호출을 포함한 중첩 호출의 최대 개수는 재귀 깊이라고 한다. pow(x,n)의 재귀 깊이는 n이다.
 * 자바스크맅브 엔진은 최대 재귀 깊이를 제한한다. (십만까지는 O) 

#### 실행 컨텍스트와 스택
 * 실제 재귀 호출이 동작하는 과정
 * 실행 중인 함수의 실행 절차에 대한 정보는 해당 함수의 실행 컨텍스트에 저장된다.
 * 함수 실행에 대한 세부 정보를 담고 있는 내부 데이터 구조며 제어 흐름의 현재위치 변수의 현재 값 this의 값 등 상세 내부 정보가 실행 컨텍스트에 저장된다.
 * 함수 호출 일회당 하나의 실행 컨텍스트가 생성된다.
 * 함수 내부에 중첩 호출이 있을 때 절차
 * 1.현재 함수의 실행이 일시 중지
 * 2.중지된 함수와 연관된 실행 컨텍스트는 스택이라는 특별한 자료 구조에 저장
 * 3.중첩 호출이 실행
 * 4.중첩 호출 실행이 끝난 이후 실행 컨텍스트 스택에서 일시 중단한 함수의 실행 컨텍스트를 꺼내오고 중단한 함수의 실행을 다시 이어간다.

##### pow(2, 3)
 * pow(2, 3) 을 호출하는 순간 실행 컨텍스트엔 x = 2, n = 3 이 저장되고 실행 흐름은 함수의 첫 번째 줄에 위치
 * 함수 실행이 시작되는 순간 : Context: { x: 2, n: 3, 첫 번째 줄} call:pow(2,3)
 * 조건 n == 1 이 만족하지 않으므로 else 문으로 넘어건다.
```js
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) );
```
 * 재귀 깊이는 스택에 들어가는 실행 컨텍스트 수의 최댓값과 같다.
 * 실행 컨텍스트는 메모리를 차지하므로 재귀를 사용할 땐 메모리 요구사항에 유의해야 한다.
 * 재귀를 이용해 작성한 코드는 반복문을 사용한 코드로 다시 작성 가능.

#### 재귀적 순회
 * 재귀는 재귀적 순회를 구현할 때 유용
 * 예시 : 모든 임직원의 급여를 더한 값을 구할 때
 * 1.임직원 배열을 가진 단순한 부서 - 간단한 반복문으로 급여 합계를 구한다.
 * 2.n개의 하위부서가 있는 객체 - 각 하위 부서에 속한 임직원의 급여 합계를 얻기 위해 n번의 재귀호출을 하고 최종적으로 모든 하위부서 임직원 급여를 더한다.
 * 배열을 사용하는 경우 재귀의 베이스가 된다.
 * 객체를 사용하는 경우 재귀 단계가 된다.
```js
let company = { // 동일한 객체(간결성을 위해 약간 압축함)
  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 1600 }],
  development: {
    sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
    internals: [{name: 'Jack', salary: 1300}]
  }
};

// 급여 합계를 구해주는 함수
function sumSalaries(department) {
  if (Array.isArray(department)) { // 첫 번째 경우
    return department.reduce((prev, current) => prev + current.salary, 0); // 배열의 요소를 합함
  } else { // 두 번째 경우
    let sum = 0;
    for (let subdep of Object.values(department)) {
      sum += sumSalaries(subdep); // 재귀 호출로 각 하위 부서 임직원의 급여 총합을 구함
    }
    return sum;
  }
}

alert(sumSalaries(company)); // 7700
```

#### 재귀적 구조
 * 재귀적 자료 구조는 자기 자신의 이루를 복제하는 형태의 자료 구조다.
 * 회사의 부서객체는 두 가지 종류로 나뉜다.
 * 1.사람들로 구성된 배열
 * 2.하위 부서로 이루어진 객체
 * HTML과 XML도 재귀적 자료 구조 형태를 띈다.
 * 1.일반 텍스트
 * 2.HTML-주석
 * 3.이 외의 HTML 태그

#### 연결 리스트
 * 객체에 빠르게 삽입 혹은 삭제를 해야 할 때 배열 대신 연결 리스트라 불리는 자료 구조 사용가능
 * 연결 리스트의 요소는 객체와 아래 프로퍼티들을 조합해 정의
 * 1.value
 * 2.next : 다음 연결 리스트 요소를 참조하는 프로퍼티 다음 요소가 없을 땐 null이 된다.
 * 예시 
```js
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
```

### 요약
 * 재귀 : 함수 내부에서 자기 자신을 호출하는 것을 나타내는 프로그래밍 용어이다. 재귀 함수는 우아하게 원하는 문제를 해결할 때 자주 쓰인다.
 * 함수가 자신을 호출하는 단계를 재귀 단계라고 부른다. 재귀의 베이스는 작업을 아주 간단하게 만들어서 함수가 더 이상은 서브 호출을 만들지 않게 해주는 인수다.
 * 재귀적으로 정의된 자료 구조는 자기 자신을 이용해 자료 구조를 정의한다.
 * 재귀적으로 정의된 자료구조에 속하는 연결 리스트는 리스트 혹은 null을 참조하는 객체로 이루어진 데이터 구조를 사용해 정의된다.
 * 모든 재귀 함수는 반복문을 사용한 함수로 다시 작성할 수 있다. 
 * 재귀를 사용하면 구현과 유지보수가 쉽다.
