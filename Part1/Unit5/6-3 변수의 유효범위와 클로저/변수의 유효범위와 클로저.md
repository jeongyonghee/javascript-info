#### 변수의 유효범위와 클로저
  * 함수가 생성된 이후에 외부 변수가 변경되면 발생하는 일, 매개변수를 통해 함수를 넘기고 멀리 떨어진 코드에서 호출할 때 발생하는 일을 알아보기

#### 코드 블록
  * 코드 블록 { } 안에서 선언한 변수는 블록안에서만 사용 가능하다.
  * 지역 변수를 선언하고 조작을 해도 결과를 밖에서 볼 순 없다.
  * 예시 : 
```js
{
  let message = "안녕하세요."; 

  alert(message); // 안녕하세요.
}

alert(message); // ReferenceError: message is not defined
```
  * 이런 블록의 특징은 특정 작업을 수행하는 코드를 한데 묶어두는 용도로 활용 가능
  * 블록 안엔 작업 수행에만 필요한 변수가 들어간다.
  * 블록이 없는 상태에서 이미 선언된 변수와 동일한 이름을 가진 변수를 let으로 선언하면 에러가 발생
  * if for while 등에서도 마찬가지로 코드블럭 안에서 선언한 변수는 오직 블록 안에서만 접근이 가능하다.
  * 예시
```js
if (true) {
  let phrase = "안녕하세요!";

  alert(phrase); // 안녕하세요!
}

alert(phrase); // 에러발생
```
  * if 블록 밖에 있는 alert은 phrase에 접근할 수 없기 때문에 위 예시를 실행하면 에러가 발생한다.
  * 이런 특징은 변수의 유효 범위를 블록 범위 특히 if문 범위로 한정시킬 수 있어서 유용하다.
  * if문 뿐만아니라 for while 반복문에서도 동일한 특징이 적용된다.
  * for 문에서 for(let i) 는  코드블럭 밖에 있긴 하지만 코드블럭 안에 속하는 코드로 취급된다.

#### 중첩 함수
  * 함수 내부에서 선언한 함수는 중첩 함수라고 부른다.
  * 예시
```js
function sayHiBye(firstName, lastName) {

  // 헬퍼(helper) 중첩 함수
  function getFullName() {
    return firstName + " " + lastName;
  }

  alert( "Hello, " + getFullName() );
  alert( "Bye, " + getFullName() );

}
```
  * 중첩 함수는 새로운 객체의 프로퍼티 형태나 중첩 함수 그 자체로 반환될 수 있다.
  * 반환된 중첩 함수는 어디서든 호출 가능하며 외부 변수에 접근 가능하다
  * 예시2 :
```js
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();

alert( counter() ); // 0
alert( counter() ); // 1
alert( counter() ); // 2
```

#### 렉시컬 환경
  ##### 1.변수
  * 자바스크립트에선 실행 중인 함수 코드 블록 스크립트 전체는 렉시컬 환경 이라 불리는 내부 숨김 연관 객체를 갖는다.
  * 렉시컬 환경 객체는 두 부분으로 구성된다. 
  * 1. 환경 레코드 : 모든 지역 변수를 프로퍼티로 저장하고 있는 객체다. this값과 같은 기타 정보도 여기에 저장된다.
  * 2. 외부 렉시컬 환경에 대한 참조 : 외부 코드와 연관
  * 변수는 특수 내부 객체인 환경 레코드의 프로퍼티일 뿐이다. 변수를 가져오거나 변경하는 것은 환경 레코드의 프로퍼티를 가져오거나 변경함을 의미한다.
  
  ##### 2.함수 선언문
  * 함수 선언문으로 선언한 함수는 일반 변수와 달리 바로 초기화 된다.
  * 함수 선언문으로 선언한 함수는 렉시컬 환경이 만들어지는 즉시 사용할 수 있다. (변수는 let이나 const를 만나 선언이 될 때까지 사용 불가)
  * 함수 표현식은 해당하지 않는다.

  ##### 3.내부와 외부 렉시컬 환경
  * 함수를 호출해 실행하면 새로운 렉시컬 환경이 자동으로 만들어진다. 이 렉시컬 환경엔 함수 호출 시 넘겨받은 매개변수와 함수의 지역 변수가 저장된다.
  * 함수가 호출 중인 동안엔 호출 중인 함수를 위한 내부 렉시컬 환경과 내부 렉시컬 환경이 가리키는 외부 렉시컬 환경을 갖게 된다.
  * 코드에서 변수에 접근할 땐 먼저 내부 렉시컬 환경을 검색 범위로 잡는다. 
  * 내부 렉시컬 환경에서 원하는 변수를 찾지 못하면 검색 범위를 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 확장한다. 
  * 이 과정은 검색 범위가 전역 렉시컬 환경으로 확장될 때까지 반복

  ##### 4.함수를 반환하는 함수
  * makeCounter 예시
  * makeCounter()를 호출할 때마다 새로운 렉시컬 환경 객체가 만들어지고 여기에 makeCounter를 실행하는데 필요한 변수들이 저장된다.
  * 모든 함수는 함수가 생성도니 곳의 렉시컬 환경을 기억한다. 
  * 함수는 [[Environment]] 라 불리는 숨김 프로퍼티를 갖는데 여기에 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장된다.
  * 따라서 counter.[[Environment]] 엔 {counter: 0} 이 있는 렉시컬 환경에 대한 참조가 저장된다.
  * 호출 장소와 상관없이 함수가 자신이 태어난 곳을 기억할 수 있는 건 [[Environment]] 프로퍼티 때문이다.
  * count++ 이 실행되면서 값이 증가하는 이유는 변숫값 갱신은 변수가 저장된 렉시컬 환경에서 이뤄지기 때문

###### 클로저
  * 클로저는 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미한다. (몇몇 언어에선 클로저를 구현 불가, 특수한 방식으로 함수를 작성해야함)
  * 자바스크립트의 함수는 숨김 프로퍼티인 [[Environment]]를 이용해 자신이 어디서 만들어 졌는지를 기억 함수 본문에선 [[Environment]]를 사용해 외부 변수에 접근한다.

#### 가비지 컬렉션
  * 함수 호출이 끝나면 함수에 대응하는 렉시컬 환경이 메모리에서 제거된다. 함수와 관련된 변수들은 이때 모두 사라진다.
  * 함수 호출이 끝나면 관련 변수를 참조할 수 없는 이유(모든 객체는 도달 가능한 상태일 때만 메모리에 유지)
  * 호출이 끝난후에도 도달 가능한 중첩 함수가 있을 순 있다. 이때는 이 중첩함수의 [[Environment]] 프로퍼티에 외부 함수 렉시컬 환경에 대한 정보가 저장된다.(도달 가능한 상태)
  * 예시 
```js
function f() {
  let value = 123;

  return function() {
    alert(value);
  }
}

let g = f(); // g.[[Environment]]에 f() 호출 시 만들어지는 렉시컬 환경 정보 저장
```
  * 주의할 점은 f()를 여러번 호출하고 그 결과를 어딘가에 저장하는 경우 호출 시 만들어지는 각 렉시컬 환경 모두가 메모리에 유지된다.(메모리에서 삭제 x)
  * 렉시컬 환경 객체를 참조하는 중첩 함수가 하나라도 있으면 사라지지 않는다. (g = null 이 되지 않는 이상 사라지지 않는다)

#### 최적화 프로세스
  * 함수가 살아있는 동안 이론상으론 모든 외부 변수가 메모리에 유지되지만 자바스크립트 엔진이 이를 지속해서 최적화한다.
  * 변수 사용을 분석하고 외부 변수가 사용되지 않는다고 판단되면 메모리에서 제거한다.
  * 디버깅 시 최적화 과정에서 제거된 변수를 사용할 수 없다는 점은 V8 엔진(Chrome, Opera)의 주요 부작용이다.
